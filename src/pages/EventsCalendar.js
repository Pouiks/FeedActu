// src/pages/EventsCalendar.js - VERSION SIMPLE QUI FONCTIONNE
import React, { useState, useMemo } from 'react';
import { useAuth } from '../hooks/useAuth';
import { useNavigate } from 'react-router-dom';
import { Alert, Snackbar, Box, Card } from '@mui/material';
import { Add } from '@mui/icons-material';
import ModalPublicationForm from '../components/ModalPublicationForm';
import PageHeader from '../components/PageHeader';
import { useResidence } from '../context/ResidenceContext';
import { usePublications } from '../context/PublicationsContext';

import FullCalendar from '@fullcalendar/react';
import dayGridPlugin from '@fullcalendar/daygrid';
import interactionPlugin from '@fullcalendar/interaction';
import frLocale from '@fullcalendar/core/locales/fr';

export default function EventsCalendar() {
  const { ensureAuthenticated } = useAuth();
  const { currentResidenceId, currentResidenceName } = useResidence();
  const { getPublications, addPublication, updatePublication, getPublicationById } = usePublications();
  const [openModal, setOpenModal] = useState(false);
  const [editingEvent, setEditingEvent] = useState(null); // NOUVEAU : Pour l'√©dition
  const [notification, setNotification] = useState({
    open: false,
    message: '',
    severity: 'success'
  });
  const navigate = useNavigate();
  const [selectedDate, setSelectedDate] = useState(null);

  // R√©cup√©rer les √©v√©nements depuis le contexte
  const events = getPublications('events');

  // Filtrer les √©v√©nements par r√©sidence (m√©moris√© pour performance)
  const filteredEvents = useMemo(() => 
    events.filter(event => {
      // G√©rer les diff√©rents formats de r√©sidence
      if (event.targetResidences && Array.isArray(event.targetResidences)) {
        return event.targetResidences.includes(currentResidenceId);
      }
      // Format legacy avec residence_id
      return event.residence_id === currentResidenceId;
    }),
    [events, currentResidenceId]
  );

  // Convertir pour FullCalendar (m√©moris√© pour performance)
  const calendarEvents = useMemo(() => 
    filteredEvents.map(event => {
      console.log('üîç DEBUG - √âv√©nement √† convertir:', event);
      
      // Format harmonis√© : startDate/endDate (prioritaire)
      let startDateTime = event.startDate;
      let endDateTime = event.endDate;
      
      // Fallback pour les anciens formats (compatibilit√©)
      if (!startDateTime || !endDateTime) {
        if (event.eventDate && event.startTime && event.endTime) {
          // Format legacy mockData
          startDateTime = `${event.eventDate}T${event.startTime}:00`;
          endDateTime = `${event.eventDate}T${event.endTime}:00`;
        } else {
          // Format de fallback ultime
          const date = event.eventDate || event.publicationDate || new Date().toISOString().split('T')[0];
          startDateTime = `${date}T09:00:00`;
          endDateTime = `${date}T10:00:00`;
        }
      }
      
      console.log('üìÖ Dates harmonis√©es pour FullCalendar:', { startDateTime, endDateTime });
      
      return {
        id: event.id.toString(),
        title: event.title || '√âv√©nement sans titre',
        start: startDateTime,
        end: endDateTime,
        extendedProps: {
          ...event,
          isArchived: event.status === 'Archiv√©'
        }
      };
    }), [filteredEvents]
  );

  // === DRAG & DROP SIMPLE QUI FONCTIONNE ===
  const handleEventDrop = (dropInfo) => {
    try {
      ensureAuthenticated('d√©placer un √©v√©nement');
      
      const newDate = dropInfo.event.start.toISOString().split('T')[0];
      
      // TODO: Mise √† jour via le contexte pour le drag & drop
      // Pour l'instant on garde l'ancien syst√®me pour le drag & drop
      // setEvents(prevEvents => 
      //   prevEvents.map(event => 
      //     event.id === eventId 
      //       ? { ...event, eventDate: newDate }
      //       : event
      //   )
      // );
      
      setNotification({
        open: true,
        message: `√âv√©nement "${dropInfo.event.title}" d√©plac√© au ${new Date(newDate).toLocaleDateString('fr-FR')} !`,
        severity: 'success'
      });
      
    } catch (error) {
      dropInfo.revert(); // Annuler le d√©placement
      setNotification({
        open: true,
        message: 'Erreur: vous devez √™tre connect√© pour d√©placer un √©v√©nement',
        severity: 'error'
      });
    }
  };

  // Clic sur √©v√©nement - Ouvrir popup de modification
  const handleEventClick = (clickInfo) => {
    try {
      ensureAuthenticated('modifier un √©v√©nement');
      
      const eventId = clickInfo.event.id;
      const event = getPublicationById('events', eventId);
      
      if (event) {
        setEditingEvent(event);
        setSelectedDate(null); // Pas de date pr√©s√©lectionn√©e en mode √©dition
        setOpenModal(true);
      } else {
        setNotification({
          open: true,
          message: '√âv√©nement introuvable',
          severity: 'error'
        });
      }
    } catch (error) {
      setNotification({
        open: true,
        message: 'Vous devez √™tre connect√© pour modifier un √©v√©nement',
        severity: 'error'
      });
    }
  };

  // Clic sur date
  const handleDateClick = (dateInfo) => {
    try {
      ensureAuthenticated('cr√©er un nouvel √©v√©nement');
      setSelectedDate(dateInfo.dateStr);
      setEditingEvent(null); // S'assurer qu'on n'est pas en mode √©dition
      setOpenModal(true);
    } catch (error) {
      setNotification({
        open: true,
        message: 'Vous devez √™tre connect√© pour cr√©er un √©v√©nement',
        severity: 'error'
      });
    }
  };

  const handleSubmitEvent = async (eventData) => {
    try {
      ensureAuthenticated(editingEvent ? 'modifier un √©v√©nement' : 'cr√©er un nouvel √©v√©nement');
      
      if (editingEvent) {
        // Mise √† jour d'un √©v√©nement existant
        await updatePublication('events', editingEvent.id, {
          ...eventData,
          updatedAt: new Date().toISOString()
        });
        setNotification({
          open: true,
          message: `√âv√©nement "${eventData.title}" mis √† jour avec succ√®s !`,
          severity: 'success'
        });
      } else {
        // Cr√©ation d'un nouvel √©v√©nement
        await addPublication('events', eventData);
        setNotification({
          open: true,
          message: '√âv√©nement cr√©√© avec succ√®s !',
          severity: 'success'
        });
      }
      
      setOpenModal(false);
      setSelectedDate(null);
      setEditingEvent(null);
      
    } catch (error) {
      console.error('‚ùå Erreur lors de la soumission:', error);
      setNotification({
        open: true,
        message: editingEvent ? 'Erreur lors de la mise √† jour de l\'√©v√©nement' : 'Erreur lors de la cr√©ation de l\'√©v√©nement',
        severity: 'error'
      });
    }
  };

  const handleNewEventClick = () => {
    try {
      ensureAuthenticated('cr√©er un nouvel √©v√©nement');
      setSelectedDate(null); // Pas de date pr√©s√©lectionn√©e
      setEditingEvent(null); // S'assurer qu'on n'est pas en mode √©dition
      setOpenModal(true);
    } catch (error) {
      setNotification({
        open: true,
        message: 'Vous devez √™tre connect√© pour cr√©er un √©v√©nement',
        severity: 'error'
      });
    }
  };

  const getInitialValues = () => {
    if (editingEvent) {
      // Mode √©dition - convertir vers le nouveau format harmonis√©
      console.log('üìÖ Mode √©dition - √âv√©nement existant:', editingEvent);
      
      return {
        ...editingEvent,
        // Convertir les anciens formats vers le nouveau
        eventDateTimeStart: editingEvent.startDate ? new Date(editingEvent.startDate) : 
                           (editingEvent.eventDate && editingEvent.startTime ? 
                            new Date(`${editingEvent.eventDate}T${editingEvent.startTime}:00`) : null),
        eventDateTimeEnd: editingEvent.endDate ? new Date(editingEvent.endDate) : 
                         (editingEvent.eventDate && editingEvent.endTime ? 
                          new Date(`${editingEvent.eventDate}T${editingEvent.endTime}:00`) : null)
      };
    } else if (selectedDate) {
      // Mode cr√©ation avec date pr√©s√©lectionn√©e
      const selectedDateTime = new Date(selectedDate);
      selectedDateTime.setHours(14, 0, 0, 0);
      
      const endDateTime = new Date(selectedDate);
      endDateTime.setHours(15, 0, 0, 0);
      
      console.log('üìÖ Date s√©lectionn√©e dans le calendrier:', selectedDate);
      console.log('üìÖ Valeurs initiales harmonis√©es:', {
        eventDateTimeStart: selectedDateTime,
        eventDateTimeEnd: endDateTime
      });
      
      return { 
        eventDateTimeStart: selectedDateTime,
        eventDateTimeEnd: endDateTime
      };
    }
    // Mode cr√©ation normale
    return {};
  };

  const handleCloseNotification = () => {
    setNotification({ ...notification, open: false });
  };

  return (
    <>
      <PageHeader
        title="Calendrier des √©v√©nements"
        subtitle={`Visualisez et g√©rez les √©v√©nements de ${currentResidenceName || 'votre r√©sidence'}`}
        breadcrumbs={[
          { label: 'Dashboard', href: '/' },
          { label: 'Calendrier', href: '/calendar' }
        ]}
                actions={[
          {
            label: 'Nouveau √âv√©nement',
            icon: <Add />,
            variant: 'contained',
            props: {
              onClick: handleNewEventClick
            }
          }
        ]}
        stats={[
          { label: '√âv√©nements ce mois', value: filteredEvents.filter(e => {
            const eventMonth = new Date(e.eventDate).getMonth();
            const currentMonth = new Date().getMonth();
            return eventMonth === currentMonth && e.status === 'Publi√©';
          }).length.toString() },
          { label: 'Total √©v√©nements', value: filteredEvents.length.toString() }
        ]}
      />

      <Card className="directus-card" sx={{ p: 3 }}>
        <Box sx={{ 
          '& .fc': {
            '--fc-border-color': 'var(--theme-border-subdued)',
            '--fc-button-bg-color': 'var(--theme-primary)',
            '--fc-button-border-color': 'var(--theme-primary)',
            '--fc-button-hover-bg-color': 'var(--theme-primary-600)',
            '--fc-button-active-bg-color': 'var(--theme-primary-700)',
            '--fc-today-bg-color': 'var(--theme-primary-50)',
            '--fc-event-bg-color': 'var(--theme-primary)',
            '--fc-event-border-color': 'var(--theme-primary-600)',
            fontFamily: 'inherit'
          },
          '& .fc-toolbar-title': {
            color: 'var(--theme-foreground-normal)',
            fontWeight: 600
          },
          '& .fc-daygrid-day-number': {
            color: 'var(--theme-foreground-normal)'
          },
          '& .fc-col-header-cell': {
            backgroundColor: 'var(--theme-background-accent)',
            borderColor: 'var(--theme-border-subdued)'
          },
          '& .fc-daygrid-day': {
            '&:hover': {
              backgroundColor: 'var(--theme-background-accent)'
            }
          },
          '& .fc-event': {
            cursor: 'pointer',
            borderRadius: 'var(--theme-border-radius)',
            '&:hover': {
              opacity: 0.8
            }
          }
        }}>
          <FullCalendar
            plugins={[dayGridPlugin, interactionPlugin]}
            initialView="dayGridMonth"
            locale={frLocale}
            events={calendarEvents}
            editable={true}
            droppable={true}
            eventDrop={handleEventDrop}
            eventClick={handleEventClick}
            dateClick={handleDateClick}
            height="auto"
            headerToolbar={{
              left: 'prev,next today',
              center: 'title',
              right: 'dayGridMonth,dayGridWeek'
            }}
            buttonText={{
              today: 'Aujourd\'hui',
              month: 'Mois',
              week: 'Semaine'
            }}
            dayMaxEvents={3}
            moreLinkText="plus"
            eventDisplay="block"
            displayEventTime={true}
            eventTimeFormat={{
              hour: '2-digit',
              minute: '2-digit',
              hour12: false
            }}
          />
        </Box>
      </Card>

      <ModalPublicationForm
        open={openModal}
        handleClose={() => {
          setOpenModal(false);
          setSelectedDate(null);
          setEditingEvent(null);
        }}
        onSubmit={handleSubmitEvent}
        entityName="√âv√©nement"
        initialValues={getInitialValues()}
        isEditing={!!editingEvent}
        fields={[
          { name: 'title', label: 'Titre de l\'√©v√©nement', type: 'text', required: true },
          { name: 'description', label: 'Description', type: 'wysiwyg', required: true },
          { name: 'eventDateTime', label: 'Date et heure de l\'√©v√©nement', type: 'daterange', required: true },
          { name: 'location', label: 'Lieu', type: 'text', required: true },
          { name: 'eventImage', label: 'Image de l\'√©v√©nement', type: 'image' },
          { name: 'hasParticipantLimit', label: 'Limiter le nombre de participants', type: 'checkbox' },
          { name: 'maxParticipants', label: 'Nombre max de participants', type: 'number', showIf: 'hasParticipantLimit' }
        ]}
      />

      <Snackbar
        open={notification.open}
        autoHideDuration={6000}
        onClose={handleCloseNotification}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
      >
        <Alert 
          onClose={handleCloseNotification} 
          severity={notification.severity}
          variant="filled"
          sx={{ width: '100%' }}
        >
          {notification.message}
        </Alert>
      </Snackbar>
    </>
  );
}