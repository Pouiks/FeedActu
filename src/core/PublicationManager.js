/**
 * üèóÔ∏è PUBLICATION MANAGER - FONCTION PRINCIPALE UNIFI√âE
 * 
 * Cette classe centralise TOUTE la logique de gestion des publications.
 * JAMAIS MODIFIER cette logique principale - seuls les templates peuvent changer.
 * 
 * ‚úÖ Avantages :
 * - Code unifi√© et maintenable
 * - Logique de s√©curit√© centralis√©e
 * - Gestion d'erreurs coh√©rente
 * - Extensibilit√© facile (nouveaux types)
 * - Tests centralis√©s
 */

import { useAuth } from '../hooks/useAuth';
import { usePublications } from '../context/PublicationsContext';
import { normalizeStatus, statusToEnglish } from '../utils/publicationStatus';
import { PublicationLogger } from '../utils/publicationLogger';

/**
 * üìã TEMPLATES DE PUBLICATION - Configuration par type
 */
export const PUBLICATION_TEMPLATES = {
  posts: {
    entityName: 'Post',
    apiEndpoint: 'posts',
    fields: [
      { name: 'title', label: 'Titre', type: 'text', required: true, placeholder: 'Entrez le titre du post...' },
      { name: 'message', label: 'Message', type: 'wysiwyg', required: true },
      { name: 'imagesBase64', label: 'Images', type: 'images', required: false, helperText: 'Chargez des images pour le post' },
      { name: 'categoryId', label: 'Cat√©gorie', type: 'select', required: true, options: [
        { value: 'CAT-001', label: 'Information' },
        { value: 'CAT-002', label: '√âv√©nement' },
        { value: 'CAT-003', label: 'Urgent' },
        { value: 'CAT-004', label: 'Maintenance' },
        { value: 'CAT-005', label: 'Vie communautaire' }
      ]},
      { name: 'publishAt', label: 'Date de publication', type: 'datetime', required: true, helperText: 'Date et heure de publication du post' }
    ],
    validation: {
      required: ['title', 'message', 'categoryId', 'publishAt'],
      custom: null
    },
    contractMapping: (formData, context) => ({
      title: formData.title || '',
      messageHtml: formData.message || '',
      categoryId: formData.categoryId || 'CAT-001',
      imagesBase64: formData.imagesBase64 || [],
      publishAt: formData.publishAt || new Date().toISOString().slice(0, 19).replace('T', ' ')
    })
  },

  events: {
    entityName: '√âv√©nement',
    apiEndpoint: 'events',
    fields: [
      { name: 'title', label: 'Titre de l\'√©v√©nement', type: 'text', required: true },
      { name: 'description', label: 'Description', type: 'wysiwyg', required: true },
      { name: 'startAt', label: 'Date et heure de d√©but', type: 'datetime', required: true, disablePast: true, helperText: 'Date et heure de d√©but de l\'√©v√©nement' },
      { name: 'endAt', label: 'Date et heure de fin', type: 'datetime', required: true, disablePast: true, helperText: 'Date et heure de fin de l\'√©v√©nement' },
      { name: 'location', label: 'Lieu', type: 'text', required: true },
      { name: 'capacity', label: 'Capacit√© maximale', type: 'number', required: false, helperText: 'Nombre maximum de participants (optionnel)' },
      { name: 'imagesBase64', label: 'Images', type: 'images', required: false, helperText: 'Chargez des images pour l\'√©v√©nement' },
      { name: 'publishAt', label: 'Date de publication', type: 'datetime', required: true, helperText: 'Date et heure de publication de l\'√©v√©nement' }
    ],
    validation: {
      required: ['title', 'description', 'startAt', 'endAt', 'location', 'publishAt'],
      custom: (formData) => {
        const errors = {};
        const startDate = formData.startAt;
        const endDate = formData.endAt;
        
        if (startDate && endDate && new Date(endDate) <= new Date(startDate)) {
          errors.endAt = 'L\'heure de fin doit √™tre apr√®s l\'heure de d√©but';
        }
        
        return errors;
      }
    },
    contractMapping: (formData, context) => ({
      title: formData.title || '',
      descriptionHtml: formData.description || '',
      startAt: formData.startAt ? new Date(formData.startAt).toISOString().slice(0, 19).replace('T', ' ') : '',
      endAt: formData.endAt ? new Date(formData.endAt).toISOString().slice(0, 19).replace('T', ' ') : '',
      location: formData.location || '',
      capacity: formData.capacity ? parseInt(formData.capacity) : 0,
      imagesBase64: formData.imagesBase64 || [],
      publishAt: formData.publishAt ? new Date(formData.publishAt).toISOString().slice(0, 19).replace('T', ' ') : new Date().toISOString().slice(0, 19).replace('T', ' ')
    })
  },

  surveys: {
    entityName: 'Sondage',
    apiEndpoint: 'surveys',
    fields: [
      { name: 'question', label: 'Question du sondage', type: 'text', required: true },
      { name: 'options', label: 'Options de r√©ponse', type: 'pollAnswers', required: true },
      { name: 'allowMultiple', label: 'Autoriser plusieurs r√©ponses', type: 'checkbox' },
      { name: 'answerDeadline', label: 'Date limite de vote', type: 'datetime', required: false, helperText: 'Date limite pour voter (optionnel)' },
      { name: 'imagesBase64', label: 'Images', type: 'images', required: false, helperText: 'Chargez des images pour le sondage' },
      { name: 'publishAt', label: 'Date de publication', type: 'datetime', required: true, helperText: 'Date et heure de publication du sondage' }
    ],
    validation: {
      required: ['question', 'options', 'publishAt'],
      custom: (formData, pollAnswers) => {
        const errors = {};
        const validAnswers = pollAnswers?.filter(answer => answer.trim() !== '') || [];
        
        if (validAnswers.length < 2) {
          errors.options = 'Au moins 2 options sont requises';
        }
        
        return errors;
      }
    },
    contractMapping: (formData, context) => ({
      question: formData.question || '',
      options: context.pollAnswers?.filter(answer => answer.trim() !== '') || [],
      allowMultiple: formData.allowMultiple || false,
      answerDeadline: formData.answerDeadline ? new Date(formData.answerDeadline).toISOString().slice(0, 19).replace('T', ' ') : undefined,
      imagesBase64: formData.imagesBase64 || [],
      publishAt: formData.publishAt ? new Date(formData.publishAt).toISOString().slice(0, 19).replace('T', ' ') : new Date().toISOString().slice(0, 19).replace('T', ' ')
    })
  },

  alerts: {
    entityName: 'Alerte',
    apiEndpoint: 'alerts',
    fields: [
      { name: 'title', label: 'Titre', type: 'text', required: true },
      { name: 'message', label: 'Message', type: 'wysiwyg', required: true },
      { name: 'alertTypeId', label: 'Type d\'alerte', type: 'select', required: true, options: [
        { value: 'ALERT-TYPE-001', label: 'Information' },
        { value: 'ALERT-TYPE-002', label: 'Avertissement' },
        { value: 'ALERT-TYPE-003', label: 'Urgence' },
        { value: 'ALERT-TYPE-004', label: 'Maintenance' }
      ]},
      { name: 'priorityId', label: 'Priorit√©', type: 'select', required: true, options: [
        { value: 'PRIO-001', label: 'Faible' },
        { value: 'PRIO-002', label: 'Moyenne' },
        { value: 'PRIO-003', label: '√âlev√©e' },
        { value: 'PRIO-004', label: 'Critique' }
      ]},
      { name: 'publishAt', label: 'Date de publication', type: 'datetime', required: true, helperText: 'Date et heure de publication de l\'alerte' }
    ],
    validation: {
      required: ['title', 'message', 'alertTypeId', 'priorityId', 'publishAt'],
      custom: null
    },
    contractMapping: (formData, context) => ({
      title: formData.title || '',
      messageHtml: formData.message || '',
      alertTypeId: formData.alertTypeId || 'ALERT-TYPE-001',
      priorityId: formData.priorityId || 'PRIO-001',
      publishAt: formData.publishAt ? new Date(formData.publishAt).toISOString().slice(0, 19).replace('T', ' ') : new Date().toISOString().slice(0, 19).replace('T', ' ')
    })
  },

  dailyAdvices: {
    entityName: 'Message du jour',
    apiEndpoint: 'daily-advices',
    fields: [
      { name: 'title', label: 'Titre', type: 'text', required: true },
      { name: 'message', label: 'Message', type: 'wysiwyg', required: true },
      { name: 'priorityId', label: 'Priorit√©', type: 'select', required: true, options: [
        { value: 'PRIO-001', label: 'Faible' },
        { value: 'PRIO-002', label: 'Moyenne' },
        { value: 'PRIO-003', label: '√âlev√©e' },
        { value: 'PRIO-004', label: 'Critique' }
      ]},
      { name: 'publishAt', label: 'Date de publication', type: 'datetime', required: true, helperText: 'Date et heure de publication du message' }
    ],
    validation: {
      required: ['title', 'message', 'priorityId', 'publishAt'],
      custom: null
    },
    contractMapping: (formData, context) => ({
      title: formData.title || '',
      messageHtml: formData.message || '',
      priorityId: formData.priorityId || 'PRIO-001',
      publishAt: formData.publishAt ? new Date(formData.publishAt).toISOString().slice(0, 19).replace('T', ' ') : new Date().toISOString().slice(0, 19).replace('T', ' ')
    })
  }
};

/**
 * üèóÔ∏è CLASSE PRINCIPALE - PublicationManager
 * 
 * R√àGLE ABSOLUE : Cette classe ne doit JAMAIS √™tre modifi√©e pour des besoins sp√©cifiques.
 * Seuls les TEMPLATES ci-dessus peuvent √™tre adapt√©s.
 */
export class PublicationManager {
  constructor() {
    this.auth = null;
    this.publications = null;
    this.initialized = false;
  }

  /**
   * üîß Initialisation avec les hooks React
   */
  initialize(authHook, publicationsHook) {
    this.auth = authHook;
    this.publications = publicationsHook;
    this.initialized = true;
  }

  /**
   * üîí VALIDATION DE S√âCURIT√â CENTRALIS√âE
   * Cette fonction ne doit JAMAIS √™tre modifi√©e
   */
  validateSecurity(residenceIds, action = 'publier') {
    if (!this.initialized) {
      throw new Error('PublicationManager non initialis√©');
    }

    const { ensureAuthenticated, authorizedResidences } = this.auth;
    
    // V√©rification d'authentification
    ensureAuthenticated(action);
    
    // Validation des r√©sidences
    if (!residenceIds || residenceIds.length === 0) {
      throw new Error('Aucune r√©sidence s√©lectionn√©e pour la publication');
    }

    const authorizedIds = authorizedResidences?.map(r => r.residenceId) || [];
    const unauthorizedResidences = residenceIds.filter(id => !authorizedIds.includes(id));
    
    if (unauthorizedResidences.length > 0) {
      console.error('üö® S√âCURIT√â: Tentative de publication dans des r√©sidences non autoris√©es:', unauthorizedResidences);
      throw new Error('Vous n\'√™tes pas autoris√© √† publier dans certaines r√©sidences s√©lectionn√©es');
    }

    return residenceIds; // R√©sidences valid√©es
  }

  /**
   * üîç VALIDATION DES DONN√âES CENTRALIS√âE
   */
  validateData(type, formData, additionalData = {}) {
    const template = PUBLICATION_TEMPLATES[type];
    if (!template) {
      throw new Error(`Type de publication non support√©: ${type}`);
    }

    const errors = {};

    // Validation des champs requis
    template.validation.required.forEach(fieldName => {
      if (!formData[fieldName] || formData[fieldName] === '') {
        const field = template.fields.find(f => f.name === fieldName);
        errors[fieldName] = `${field?.label || fieldName} est requis`;
      }
    });

    // Validation personnalis√©e si d√©finie
    if (template.validation.custom) {
      const customErrors = template.validation.custom(formData, additionalData.pollAnswers);
      Object.assign(errors, customErrors);
    }

    if (Object.keys(errors).length > 0) {
      throw new Error('Donn√©es invalides');
    }

    return true;
  }

  /**
   * üìã CONSTRUCTION DU PAYLOAD SELON LE CONTRAT
   */
  buildPayload(type, formData, context) {
    const template = PUBLICATION_TEMPLATES[type];
    if (!template) {
      throw new Error(`Type de publication non support√©: ${type}`);
    }

    // Format datetime pour le contrat : yyyy-MM-dd HH:mm:ss
    const formatDateTime = (date) => {
      if (!date) return undefined;
      const d = new Date(date);
      return d.toISOString().slice(0, 19).replace('T', ' ');
    };

    // Champs communs √† tous les types
    const basePayload = {
      residenceIds: context.residenceIds,
      status: statusToEnglish(normalizeStatus(context.status)),
      publishLater: context.publishLater || false,
      authorId: context.user?.userId || context.user?.email || 'current-user',
      createdAt: formatDateTime(formData.publicationDate || new Date())
    };

    // Ajouter publishAt si publishLater est true
    if (context.publishLater && context.publishDateTime) {
      basePayload.publishAt = formatDateTime(context.publishDateTime);
    }

    // Mapping sp√©cifique par type
    const specificPayload = template.contractMapping(formData, context);

    return {
      ...basePayload,
      ...specificPayload
    };
  }

  /**
   * üöÄ FONCTION PRINCIPALE DE CR√âATION/MISE √Ä JOUR
   * Cette fonction ne doit JAMAIS √™tre modifi√©e
   */
  async handleSubmission(type, formData, context) {
    try {
      console.log(`üöÄ PublicationManager - D√©but soumission ${type}`);

      // 1. Validation de s√©curit√©
      const validatedResidences = this.validateSecurity(context.residenceIds, 
        context.isEditing ? `modifier un ${type}` : `cr√©er un nouveau ${type}`);

      // 2. Validation des donn√©es
      this.validateData(type, formData, {
        pollAnswers: context.pollAnswers
      });

      // 3. Construction du payload
      const payload = this.buildPayload(type, formData, {
        ...context,
        residenceIds: validatedResidences
      });

      // 4. Logging unifi√©
      const actionLabel = context.status === 'Publi√©' ? 'publish' : 'draft';
      console.log('publication_submit', { 
        type, 
        action: actionLabel, 
        status: context.status, 
        payload 
      });

      PublicationLogger.logPublication(type, payload, 'PREPARING', {
        user: context.user,
        authorizedResidences: this.auth.authorizedResidences
      });

      // 5. Soumission via le contexte
      if (context.isEditing) {
        await this.publications.updatePublication(type, context.editingId, payload);
      } else {
        await this.publications.addPublication(type, payload);
      }

      // 6. Notification de succ√®s
      const residenceCount = validatedResidences.length;
      const template = PUBLICATION_TEMPLATES[type];
      const successMessage = context.isEditing 
        ? `${template.entityName} mis √† jour avec succ√®s !`
        : `${template.entityName} cr√©√© avec succ√®s et publi√© dans ${residenceCount} r√©sidence${residenceCount > 1 ? 's' : ''} !`;

      console.log(`‚úÖ ${successMessage}`);
      return { success: true, message: successMessage };

    } catch (error) {
      console.error(`‚ùå Erreur PublicationManager - ${type}:`, error);
      
      // Gestion d'erreurs unifi√©e
      let friendlyMessage = `Erreur lors de ${context.isEditing ? 'la modification' : 'la cr√©ation'} du ${type}`;
      
      if (error.code === 'UNAUTHENTICATED') {
        friendlyMessage = `Vous devez √™tre connect√© pour ${context.isEditing ? 'modifier' : 'cr√©er'} un ${type}`;
      } else if (error.message) {
        friendlyMessage = error.message;
      }

      throw new Error(friendlyMessage);
    }
  }

  /**
   * üéØ M√âTHODES D'ACC√àS RAPIDE PAR TYPE
   */
  getTemplate(type) {
    return PUBLICATION_TEMPLATES[type];
  }

  getFields(type) {
    return PUBLICATION_TEMPLATES[type]?.fields || [];
  }

  getEntityName(type) {
    return PUBLICATION_TEMPLATES[type]?.entityName || type;
  }
}

// Instance singleton
export const publicationManager = new PublicationManager();

/**
 * üé£ HOOK REACT POUR UTILISER LE MANAGER
 */
export function usePublicationManager() {
  const auth = useAuth();
  const publications = usePublications();

  // Auto-initialisation
  if (!publicationManager.initialized) {
    publicationManager.initialize(auth, publications);
  }

  return {
    manager: publicationManager,
    handleSubmission: (type, formData, context) => 
      publicationManager.handleSubmission(type, formData, context),
    getTemplate: (type) => publicationManager.getTemplate(type),
    getFields: (type) => publicationManager.getFields(type),
    getEntityName: (type) => publicationManager.getEntityName(type)
  };
}
